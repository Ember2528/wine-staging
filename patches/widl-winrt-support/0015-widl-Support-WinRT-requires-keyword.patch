From 8b5c17d32ec132669fc345bce9616d6631e072ab Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 13 Oct 2020 00:31:57 +0200
Subject: [PATCH] widl: Support WinRT requires keyword.

---
 tools/widl/parser.l    |  1 +
 tools/widl/parser.y    | 45 +++++++++++++++++++++++++++++++++---------
 tools/widl/typetree.c  |  5 ++++-
 tools/widl/typetree.h  |  9 ++++++++-
 tools/widl/widltypes.h |  1 +
 5 files changed, 50 insertions(+), 11 deletions(-)

diff --git a/tools/widl/parser.l b/tools/widl/parser.l
index 9b93a53b839..946dba84cd6 100644
--- a/tools/widl/parser.l
+++ b/tools/widl/parser.l
@@ -298,6 +298,7 @@ static const struct keyword keywords[] = {
 	{"pascal",          tPASCAL,         0},
 	{"properties",      tPROPERTIES,     0},
 	{"register",        tREGISTER,       0},
+	{"requires",        tREQUIRES,       1},
 	{"runtimeclass",    tRUNTIMECLASS,   1},
 	{"short",           tSHORT,          0},
 	{"signed",          tSIGNED,         0},
diff --git a/tools/widl/parser.y b/tools/widl/parser.y
index b8c916f8336..169a5ba6386 100644
--- a/tools/widl/parser.y
+++ b/tools/widl/parser.y
@@ -38,12 +38,6 @@
 #include "expr.h"
 #include "typetree.h"
 
-typedef struct list typelist_t;
-struct typenode {
-  type_t *type;
-  struct list entry;
-};
-
 struct _import_t
 {
   char *name;
@@ -51,6 +45,8 @@ struct _import_t
 };
 
 static str_list_t *append_str(str_list_t *list, char *str);
+static type_list_t *append_type(type_list_t *list, type_t *type);
+static type_list_t *append_types(type_list_t *list, type_list_t *types);
 static attr_list_t *append_attr(attr_list_t *list, attr_t *attr);
 static attr_list_t *append_attr_list(attr_list_t *new_list, attr_list_t *old_list);
 static decl_spec_t *make_decl_spec(type_t *type, decl_spec_t *left, decl_spec_t *right,
@@ -130,6 +126,7 @@ static typelib_t *current_typelib;
 	expr_t *expr;
 	expr_list_t *expr_list;
 	type_t *type;
+	type_list_t *typelist;
 	var_t *var;
 	var_list_t *var_list;
 	declarator_t *declarator;
@@ -240,6 +237,7 @@ static typelib_t *current_typelib;
 %token tREADONLY tREF
 %token tREGISTER tREPRESENTAS
 %token tREQUESTEDIT
+%token tREQUIRES
 %token tRESTRICTED
 %token tRETVAL
 %token tRUNTIMECLASS
@@ -291,6 +289,7 @@ static typelib_t *current_typelib;
 %type <type> base_type int_std
 %type <type> enumdef structdef uniondef typedecl
 %type <type> type unqualified_type qualified_type
+%type <typelist> requires required_types
 %type <ifref> class_interface
 %type <ifref_list> class_interfaces
 %type <var> arg ne_union_field union_field s_field case enum enum_member declaration
@@ -967,8 +966,16 @@ inherit:					{ $$ = NULL; }
 interface: tINTERFACE typename			{ $$ = type_interface_declare($2, current_namespace); }
 	;
 
-interfacedef: attributes interface inherit
-	  '{' int_statements '}' semicolon_opt	{ $$ = type_interface_define($2, $1, $3, $5);
+required_types:
+	  qualified_type			{ $$ = append_type(NULL, $1); }
+	| required_types ',' required_types	{ $$ = append_types($1, $3); }
+
+requires:					{ $$ = NULL; }
+	| tREQUIRES required_types		{ $$ = $2; }
+	;
+
+interfacedef: attributes interface inherit requires
+	  '{' int_statements '}' semicolon_opt	{ $$ = type_interface_define($2, $1, $3, $6, $4);
 						  check_async_uuid($$);
 						}
 	| dispinterfacedef semicolon_opt	{ $$ = $1; }
@@ -1296,6 +1303,26 @@ static str_list_t *append_str(str_list_t *list, char *str)
     return list;
 }
 
+static type_list_t *append_type(type_list_t *list, type_t *type)
+{
+    type_list_t *entry;
+    if (!type) return list;
+    entry = xmalloc( sizeof(*entry) );
+    entry->type = type;
+    entry->next = list;
+    return entry;
+}
+
+static type_list_t *append_types(type_list_t *list, type_list_t *types)
+{
+    type_list_t *entry;
+    if (!list) return types;
+    if (!types) return list;
+    for (entry = list; entry->next; entry = entry->next) {}
+    entry->next = types;
+    return list;
+}
+
 static attr_list_t *move_attr(attr_list_t *dst, attr_list_t *src, enum attr_type type)
 {
   attr_t *attr;
@@ -2981,7 +3008,7 @@ static void check_async_uuid(type_t *iface)
         stmts = append_statement(stmts, make_statement_declaration(finish_func));
     }
 
-    type_interface_define(async_iface, map_attrs(iface->attrs, async_iface_attrs), inherit, stmts);
+    type_interface_define(async_iface, map_attrs(iface->attrs, async_iface_attrs), inherit, stmts, NULL);
     iface->details.iface->async_iface = async_iface->details.iface->async_iface = async_iface;
 }
 
diff --git a/tools/widl/typetree.c b/tools/widl/typetree.c
index b3f0725f00e..c67daa6ae8c 100644
--- a/tools/widl/typetree.c
+++ b/tools/widl/typetree.c
@@ -441,7 +441,7 @@ type_t *type_interface_declare(char *name, struct namespace *namespace)
     return type;
 }
 
-type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit, statement_list_t *stmts)
+type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit, statement_list_t *stmts, type_list_t *requires)
 {
     if (iface->defined)
         error_loc("interface %s already defined at %s:%d\n",
@@ -457,6 +457,7 @@ type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit
     iface->details.iface->inherit = inherit;
     iface->details.iface->disp_inherit = NULL;
     iface->details.iface->async_iface = NULL;
+    iface->details.iface->requires = requires;
     iface->defined = TRUE;
     compute_method_indexes(iface);
     return iface;
@@ -485,6 +486,7 @@ type_t *type_dispinterface_define(type_t *iface, attr_list_t *attrs, var_list_t
     if (!iface->details.iface->inherit) error_loc("IDispatch is undefined\n");
     iface->details.iface->disp_inherit = NULL;
     iface->details.iface->async_iface = NULL;
+    iface->details.iface->requires = NULL;
     iface->defined = TRUE;
     compute_method_indexes(iface);
     return iface;
@@ -504,6 +506,7 @@ type_t *type_dispinterface_define_from_iface(type_t *dispiface, attr_list_t *att
     if (!dispiface->details.iface->inherit) error_loc("IDispatch is undefined\n");
     dispiface->details.iface->disp_inherit = iface;
     dispiface->details.iface->async_iface = NULL;
+    dispiface->details.iface->requires = NULL;
     dispiface->defined = TRUE;
     compute_method_indexes(dispiface);
     return dispiface;
diff --git a/tools/widl/typetree.h b/tools/widl/typetree.h
index 8e04537ab4d..b238c11f615 100644
--- a/tools/widl/typetree.h
+++ b/tools/widl/typetree.h
@@ -53,7 +53,7 @@ type_t *type_new_encapsulated_union(char *name, var_t *switch_field, var_t *unio
 type_t *type_new_bitfield(type_t *field_type, const expr_t *bits);
 type_t *type_runtimeclass_declare(char *name, struct namespace *namespace);
 type_t *type_interface_declare(char *name, struct namespace *namespace);
-type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit, statement_list_t *stmts);
+type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit, statement_list_t *stmts, type_list_t *requires);
 type_t *type_dispinterface_declare(char *name);
 type_t *type_dispinterface_define(type_t *iface, attr_list_t *attrs, var_list_t *props, var_list_t *methods);
 type_t *type_dispinterface_define_from_iface(type_t *dispiface, attr_list_t *attrs, type_t *iface);
@@ -181,6 +181,13 @@ static inline type_t *type_iface_get_inherit(const type_t *type)
     return type->details.iface->inherit;
 }
 
+static inline type_list_t *type_iface_get_requires(const type_t *type)
+{
+    type = type_get_real_type(type);
+    assert(type_get_type(type) == TYPE_INTERFACE);
+    return type->details.iface->requires;
+}
+
 static inline type_t *type_iface_get_async_iface(const type_t *type)
 {
     type = type_get_real_type(type);
diff --git a/tools/widl/widltypes.h b/tools/widl/widltypes.h
index facfff21453..a3000a7417b 100644
--- a/tools/widl/widltypes.h
+++ b/tools/widl/widltypes.h
@@ -386,6 +386,7 @@ struct iface_details
   struct _type_t *inherit;
   struct _type_t *disp_inherit;
   struct _type_t *async_iface;
+  type_list_t *requires;
 };
 
 struct module_details
-- 
2.20.1

