From fd50398643cafcfa3868a9e47429db7136a16ef5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Feb 2021 11:02:09 +0100
Subject: [PATCH] widl: Factor and cleanup module type declaration and
 definition.

---
 tools/widl/parser.y   | 20 ++++++--------------
 tools/widl/typetree.c | 27 +++++++++++++++------------
 tools/widl/typetree.h |  5 +++--
 3 files changed, 24 insertions(+), 28 deletions(-)

diff --git a/tools/widl/parser.y b/tools/widl/parser.y
index 8c805e481f8..782ed39643c 100644
--- a/tools/widl/parser.y
+++ b/tools/widl/parser.y
@@ -95,7 +95,6 @@ static attr_list_t *check_struct_attrs(attr_list_t *attrs);
 static attr_list_t *check_union_attrs(attr_list_t *attrs);
 static attr_list_t *check_field_attrs(const char *name, attr_list_t *attrs);
 static attr_list_t *check_library_attrs(const char *name, attr_list_t *attrs);
-static attr_list_t *check_module_attrs(const char *name, attr_list_t *attrs);
 const char *get_attr_display_name(enum attr_type type);
 static void add_explicit_handle_if_necessary(const type_t *iface, var_t *func);
 
@@ -285,7 +284,7 @@ static typelib_t *current_typelib;
 %type <type> inherit interface interfacedef
 %type <type> interfaceref
 %type <type> dispinterface dispinterfacedef
-%type <type> module modulehdr moduledef
+%type <type> module moduledef
 %type <str> namespacedef
 %type <type> base_type int_std
 %type <type> enumdef structdef uniondef typedecl
@@ -985,19 +984,12 @@ interfaceref:
 	| tDISPINTERFACE aKNOWNTYPE		{ $$ = get_type(TYPE_INTERFACE, $2, current_namespace, 0); }
 	;
 
-module:   tMODULE aIDENTIFIER			{ $$ = type_new_module($2); }
-	| tMODULE aKNOWNTYPE			{ $$ = type_new_module($2); }
+module:   tMODULE aIDENTIFIER			{ $$ = type_module_declare($2); }
+	| tMODULE aKNOWNTYPE			{ $$ = type_module_declare($2); }
 	;
 
-modulehdr: attributes module			{ $$ = $2;
-						  $$->attrs = check_module_attrs($2->name, $1);
-						}
-	;
-
-moduledef: modulehdr '{' int_statements '}'
-	   semicolon_opt			{ $$ = $1;
-                                                  type_module_define($$, $3);
-						}
+moduledef: attributes module '{' int_statements '}' semicolon_opt
+						{ $$ = type_module_define($2, $1, $4); }
 	;
 
 storage_cls_spec:
@@ -2476,7 +2468,7 @@ attr_list_t *check_dispiface_attrs(const char *name, attr_list_t *attrs)
   return attrs;
 }
 
-static attr_list_t *check_module_attrs(const char *name, attr_list_t *attrs)
+attr_list_t *check_module_attrs(const char *name, attr_list_t *attrs)
 {
   const attr_t *attr;
   if (!attrs) return attrs;
diff --git a/tools/widl/typetree.c b/tools/widl/typetree.c
index 004f7fc7b0d..b3f0725f00e 100644
--- a/tools/widl/typetree.c
+++ b/tools/widl/typetree.c
@@ -195,16 +195,6 @@ type_t *type_new_alias(const decl_spec_t *t, const char *name)
     return a;
 }
 
-type_t *type_new_module(char *name)
-{
-    type_t *type = get_type(TYPE_MODULE, name, NULL, 0);
-    if (type->type_type != TYPE_MODULE || type->defined)
-        error_loc("%s: redefinition error; original definition was at %s:%d\n",
-                  type->name, type->loc_info.input_name, type->loc_info.line_number);
-    type->name = name;
-    return type;
-}
-
 type_t *type_new_array(const char *name, const decl_spec_t *element, int declptr,
                        unsigned int dim, expr_t *size_is, expr_t *length_is)
 {
@@ -519,12 +509,25 @@ type_t *type_dispinterface_define_from_iface(type_t *dispiface, attr_list_t *att
     return dispiface;
 }
 
-void type_module_define(type_t *module, statement_list_t *stmts)
+type_t *type_module_declare(char *name)
+{
+    type_t *type = get_type(TYPE_MODULE, name, NULL, 0);
+    if (type_get_type_detect_alias(type) != TYPE_MODULE)
+        error_loc("module %s previously not declared a module at %s:%d\n",
+                  type->name, type->loc_info.input_name, type->loc_info.line_number);
+    return type;
+}
+
+type_t *type_module_define(type_t* module, attr_list_t *attrs, statement_list_t *stmts)
 {
-    if (module->details.module) error_loc("multiple definition error\n");
+    if (module->defined)
+        error_loc("module %s already defined at %s:%d\n",
+                  module->name, module->loc_info.input_name, module->loc_info.line_number);
+    module->attrs = check_module_attrs(module->name, attrs);
     module->details.module = xmalloc(sizeof(*module->details.module));
     module->details.module->stmts = stmts;
     module->defined = TRUE;
+    return module;
 }
 
 type_t *type_coclass_declare(char *name)
diff --git a/tools/widl/typetree.h b/tools/widl/typetree.h
index 7c19da8e045..8e04537ab4d 100644
--- a/tools/widl/typetree.h
+++ b/tools/widl/typetree.h
@@ -33,12 +33,13 @@ attr_list_t *check_apicontract_attrs(const char *name, attr_list_t *attrs);
 attr_list_t *check_coclass_attrs(const char *name, attr_list_t *attrs);
 attr_list_t *check_dispiface_attrs(const char *name, attr_list_t *attrs);
 attr_list_t *check_interface_attrs(const char *name, attr_list_t *attrs);
+attr_list_t *check_module_attrs(const char *name, attr_list_t *attrs);
 attr_list_t *check_runtimeclass_attrs(const char *name, attr_list_t *attrs);
 
 type_t *type_new_function(var_list_t *args);
 type_t *type_new_pointer(type_t *ref);
 type_t *type_new_alias(const decl_spec_t *t, const char *name);
-type_t *type_new_module(char *name);
+type_t *type_module_declare(char *name);
 type_t *type_new_array(const char *name, const decl_spec_t *element, int declptr,
                        unsigned int dim, expr_t *size_is, expr_t *length_is);
 type_t *type_new_basic(enum type_basic_type basic_type);
@@ -56,7 +57,7 @@ type_t *type_interface_define(type_t *iface, attr_list_t *attrs, type_t *inherit
 type_t *type_dispinterface_declare(char *name);
 type_t *type_dispinterface_define(type_t *iface, attr_list_t *attrs, var_list_t *props, var_list_t *methods);
 type_t *type_dispinterface_define_from_iface(type_t *dispiface, attr_list_t *attrs, type_t *iface);
-void type_module_define(type_t *module, statement_list_t *stmts);
+type_t *type_module_define(type_t* module, attr_list_t *attrs, statement_list_t *stmts);
 type_t *type_coclass_define(type_t *coclass, attr_list_t *attrs, ifref_list_t *ifaces);
 type_t *type_runtimeclass_define(type_t *runtimeclass, attr_list_t *attrs, ifref_list_t *ifaces);
 type_t *type_apicontract_declare(char *name, struct namespace *namespace);
-- 
2.20.1

