From db0ad0a517ca74f0b166d515eb9fdb15d06d695a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 19 Mar 2021 14:16:16 +0100
Subject: [PATCH] hidclass.sys: Use __wine_send_input to send device
 notifications.

This currently does nothing, because winedevice.exe isn't associated
with any desktop, and the INPUT_HARDWARE messages are dropped.

In this specific case, when INPUT type is INPUT_HARDWARE and hi.uMsg is
WM_INPUT_DEVICE_CHANGE, the RAWINPUT structure usage is a non-standard
extension for Wine internal usage:

* header.wParam contains the message GIDC_ARRIVAL / GIDC_REMOVAL wparam,

* hid.bRawData contains two bytes, which are the HID device UsagePage
  and Usage bytes, instead of a real HID report.

This will let us use the same entry point and structures to send device
notifications as for the HID reports in the future (which will be sent
with INPUT_HARDWARE type / WM_INPUT uMsg instead).

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=50506
---
 dlls/hidclass.sys/Makefile.in |  2 +-
 dlls/hidclass.sys/pnp.c       | 38 +++++++++++++++++++++++++++++++++++
 2 files changed, 39 insertions(+), 1 deletion(-)

diff --git a/dlls/hidclass.sys/Makefile.in b/dlls/hidclass.sys/Makefile.in
index 4b1e9338eb4..09281c118b4 100644
--- a/dlls/hidclass.sys/Makefile.in
+++ b/dlls/hidclass.sys/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = hidclass.sys
 IMPORTLIB = hidclass
-IMPORTS   = hal ntoskrnl
+IMPORTS   = hal ntoskrnl user32
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
index de6f409a16b..9a1dcee192b 100644
--- a/dlls/hidclass.sys/pnp.c
+++ b/dlls/hidclass.sys/pnp.c
@@ -26,6 +26,7 @@
 #include "ddk/hidtypes.h"
 #include "ddk/wdm.h"
 #include "regstr.h"
+#include "winuser.h"
 #include "wine/debug.h"
 #include "wine/asm.h"
 #include "wine/list.h"
@@ -97,6 +98,9 @@ static UINT32 alloc_rawinput_handle(void)
     return InterlockedIncrement(&counter);
 }
 
+/* make sure bRawData can hold two bytes without requiring additional allocation */
+C_ASSERT(offsetof(RAWINPUT, data.hid.bRawData[2]) < sizeof(RAWINPUT));
+
 static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *bus_pdo)
 {
     WCHAR device_id[MAX_DEVICE_ID_LEN], instance_id[MAX_DEVICE_ID_LEN];
@@ -159,6 +163,8 @@ static void create_child(minidriver *minidriver, DEVICE_OBJECT *fdo)
     WCHAR pdo_name[255];
     USAGE page, usage;
     NTSTATUS status;
+    RAWINPUT rawinput;
+    INPUT input;
     INT i;
 
     status = call_minidriver(IOCTL_HID_GET_DEVICE_ATTRIBUTES, fdo, NULL, 0, &attr, sizeof(attr));
@@ -247,6 +253,23 @@ static void create_child(minidriver *minidriver, DEVICE_OBJECT *fdo)
             sizeof(HID_XFER_PACKET) + pdo_ext->u.pdo.preparsed_data->caps.InputReportByteLength);
 
     HID_StartDeviceThread(child_pdo);
+
+    rawinput.header.dwType = RIM_TYPEHID;
+    rawinput.header.dwSize = offsetof(RAWINPUT, data.hid.bRawData[2]);
+    rawinput.header.hDevice = ULongToHandle(pdo_ext->u.pdo.rawinput_handle);
+    rawinput.header.wParam = GIDC_ARRIVAL;
+    rawinput.data.hid.dwCount = 1;
+    rawinput.data.hid.dwSizeHid = 2;
+    rawinput.data.hid.bRawData[0] = pdo_ext->u.pdo.preparsed_data->caps.UsagePage;
+    rawinput.data.hid.bRawData[1] = pdo_ext->u.pdo.preparsed_data->caps.Usage;
+
+    input.type = INPUT_HARDWARE;
+    input.u.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
+    input.u.hi.wParamH = (WORD)(rawinput.header.dwSize >> 16);
+    input.u.hi.wParamL = (WORD)(rawinput.header.dwSize >> 0);
+    __wine_send_input(0, &input, &rawinput);
+
+    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
 }
 
 static NTSTATUS fdo_pnp(DEVICE_OBJECT *device, IRP *irp)
@@ -409,6 +432,21 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device, IRP *irp)
         case IRP_MN_REMOVE_DEVICE:
         {
             IRP *queued_irp;
+            RAWINPUT rawinput;
+            INPUT input;
+
+            rawinput.header.dwType = RIM_TYPEHID;
+            rawinput.header.dwSize = offsetof(RAWINPUT, data.hid.bRawData[0]);
+            rawinput.header.hDevice = ULongToHandle(ext->u.pdo.rawinput_handle);
+            rawinput.header.wParam = GIDC_REMOVAL;
+            rawinput.data.hid.dwCount = 0;
+            rawinput.data.hid.dwSizeHid = 0;
+
+            input.type = INPUT_HARDWARE;
+            input.u.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
+            input.u.hi.wParamH = (WORD)(rawinput.header.dwSize >> 16);
+            input.u.hi.wParamL = (WORD)(rawinput.header.dwSize >> 0);
+            __wine_send_input(0, &input, &rawinput);
 
             IoSetDeviceInterfaceState(&ext->u.pdo.link_name, FALSE);
             if (ext->u.pdo.is_mouse)
-- 
2.30.2

