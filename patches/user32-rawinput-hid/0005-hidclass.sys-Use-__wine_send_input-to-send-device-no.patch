From d39f9ed6bba9a603b415c3882e89fd9c8cc4ae10 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 19 Mar 2021 14:16:16 +0100
Subject: [PATCH] hidclass.sys: Use __wine_send_input to send device
 notifications.

This currently does nothing, because winedevice.exe isn't associated
with any desktop, and the INPUT_HARDWARE messages are dropped.

In this specific case, when INPUT type is INPUT_HARDWARE and hi.uMsg is
WM_INPUT_DEVICE_CHANGE, the RAWINPUT structure usage is a non-standard
extension for Wine internal usage:

* header.wParam contains the message GIDC_ARRIVAL / GIDC_REMOVAL wparam,

* hid.bRawData contains two bytes, which are the HID device UsagePage
  and Usage bytes, instead of a real HID report.

This will let us use the same entry point and structures to send device
notifications as for the HID reports in the future (which will be sent
with INPUT_HARDWARE type / WM_INPUT uMsg instead).

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=50506
---
 dlls/hidclass.sys/Makefile.in |  2 +-
 dlls/hidclass.sys/pnp.c       | 36 +++++++++++++++++++++++++++++++++++
 2 files changed, 37 insertions(+), 1 deletion(-)

diff --git a/dlls/hidclass.sys/Makefile.in b/dlls/hidclass.sys/Makefile.in
index 58bb2b5088f..ced4196d24a 100644
--- a/dlls/hidclass.sys/Makefile.in
+++ b/dlls/hidclass.sys/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = hidclass.sys
 IMPORTLIB = hidclass
-IMPORTS   = hal ntoskrnl
+IMPORTS   = hal ntoskrnl user32
 DELAYIMPORTS = setupapi
 
 EXTRADLLFLAGS = -mno-cygwin
diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
index 6e13596a32c..0fce6685b62 100644
--- a/dlls/hidclass.sys/pnp.c
+++ b/dlls/hidclass.sys/pnp.c
@@ -26,6 +26,7 @@
 #include "ddk/hidtypes.h"
 #include "ddk/wdm.h"
 #include "regstr.h"
+#include "winuser.h"
 #include "wine/debug.h"
 #include "wine/asm.h"
 #include "wine/list.h"
@@ -101,6 +102,9 @@ static NTSTATUS get_device_id(DEVICE_OBJECT *device, BUS_QUERY_ID_TYPE type, WCH
     return status;
 }
 
+/* make sure bRawData can hold two bytes without requiring additional allocation */
+C_ASSERT(offsetof(RAWINPUT, data.hid.bRawData[2]) < sizeof(RAWINPUT));
+
 static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *bus_pdo)
 {
     WCHAR device_id[MAX_DEVICE_ID_LEN], instance_id[MAX_DEVICE_ID_LEN], pdo_name[255];
@@ -112,6 +116,8 @@ static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *b
     minidriver *minidriver;
     HID_DESCRIPTOR descriptor;
     BYTE *reportDescriptor;
+    RAWINPUT rawinput;
+    INPUT input;
     INT i;
 
     if ((status = get_device_id(bus_pdo, BusQueryDeviceID, device_id)))
@@ -238,6 +244,21 @@ static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *b
 
     HID_StartDeviceThread(child_pdo);
 
+    rawinput.header.dwType = RIM_TYPEHID;
+    rawinput.header.dwSize = offsetof(RAWINPUT, data.hid.bRawData[2]);
+    rawinput.header.hDevice = ULongToHandle(pdo_ext->u.pdo.rawinput_handle);
+    rawinput.header.wParam = GIDC_ARRIVAL;
+    rawinput.data.hid.dwCount = 1;
+    rawinput.data.hid.dwSizeHid = 2;
+    rawinput.data.hid.bRawData[0] = pdo_ext->u.pdo.preparsed_data->caps.UsagePage;
+    rawinput.data.hid.bRawData[1] = pdo_ext->u.pdo.preparsed_data->caps.Usage;
+
+    input.type = INPUT_HARDWARE;
+    input.u.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
+    input.u.hi.wParamH = (WORD)(rawinput.header.dwSize >> 16);
+    input.u.hi.wParamL = (WORD)(rawinput.header.dwSize >> 0);
+    __wine_send_input(0, &input, &rawinput);
+
     fdo->Flags &= ~DO_DEVICE_INITIALIZING;
     return STATUS_SUCCESS;
 }
@@ -384,6 +405,21 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device, IRP *irp)
         case IRP_MN_REMOVE_DEVICE:
         {
             IRP *queued_irp;
+            RAWINPUT rawinput;
+            INPUT input;
+
+            rawinput.header.dwType = RIM_TYPEHID;
+            rawinput.header.dwSize = offsetof(RAWINPUT, data.hid.bRawData[0]);
+            rawinput.header.hDevice = ULongToHandle(ext->u.pdo.rawinput_handle);
+            rawinput.header.wParam = GIDC_REMOVAL;
+            rawinput.data.hid.dwCount = 0;
+            rawinput.data.hid.dwSizeHid = 0;
+
+            input.type = INPUT_HARDWARE;
+            input.u.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
+            input.u.hi.wParamH = (WORD)(rawinput.header.dwSize >> 16);
+            input.u.hi.wParamL = (WORD)(rawinput.header.dwSize >> 0);
+            __wine_send_input(0, &input, &rawinput);
 
             IoSetDeviceInterfaceState(&ext->u.pdo.link_name, FALSE);
             if (ext->u.pdo.is_mouse)
-- 
2.30.2

