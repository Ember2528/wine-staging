From 3f576ac591f515a621da1d706c85030c94fc39b3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 7 Apr 2021 12:17:40 +0200
Subject: [PATCH] server: Implement WM_INPUT_DEVICE_CHANGE message dispatch.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=50506
---
 dlls/user32/message.c  | 13 +++++++----
 dlls/user32/rawinput.c |  2 +-
 server/queue.c         | 53 +++++++++++++++++++++++++++++++++++++-----
 3 files changed, 56 insertions(+), 12 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 148b35f8caf..9af33c3291e 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2289,11 +2289,14 @@ static void accept_hardware_message( UINT hw_id )
 static BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data )
 {
     struct rawinput_thread_data *thread_data = rawinput_thread_data();
-    if (!rawinput_from_hardware_message( thread_data->buffer, msg_data ))
-        return FALSE;
 
-    thread_data->hw_id = hw_id;
-    msg->lParam = (LPARAM)hw_id;
+    if (msg->message == WM_INPUT)
+    {
+        if (!rawinput_from_hardware_message( thread_data->buffer, msg_data )) return FALSE;
+        thread_data->hw_id = hw_id;
+        msg->lParam = (LPARAM)hw_id;
+    }
+
     msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
     return TRUE;
 }
@@ -2613,7 +2616,7 @@ static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardwar
     /* hardware messages are always in physical coords */
     context = SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
 
-    if (msg->message == WM_INPUT)
+    if (msg->message == WM_INPUT || msg->message == WM_INPUT_DEVICE_CHANGE)
         ret = process_rawinput_message( msg, hw_id, msg_data );
     else if (is_keyboard_message( msg->message ))
         ret = process_keyboard_message( msg, hw_id, hwnd_filter, first, last, remove );
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index f2d64ccc23b..d95d29d7656 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -468,7 +468,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
                 i, devices[i].usUsagePage, devices[i].usUsage,
                 devices[i].dwFlags, devices[i].hwndTarget);
-        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY|RIDEV_INPUTSINK))
+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY|RIDEV_INPUTSINK|RIDEV_DEVNOTIFY))
             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
 
         d[i].usage_page = devices[i].usUsagePage;
diff --git a/server/queue.c b/server/queue.c
index 3712f79df3e..3f48e0aabdc 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1464,7 +1464,7 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
 
     *thread = NULL;
     *msg_code = msg->msg;
-    if (msg->msg == WM_INPUT)
+    if (msg->msg == WM_INPUT || msg->msg == WM_INPUT_DEVICE_CHANGE)
     {
         if (!(win = msg->win) && input) win = input->focus;
     }
@@ -1553,7 +1553,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
         if (msg->wparam == VK_SHIFT || msg->wparam == VK_LSHIFT || msg->wparam == VK_RSHIFT)
             msg->lparam &= ~(KF_EXTENDED << 16);
     }
-    else if (msg->msg != WM_INPUT)
+    else if (msg->msg != WM_INPUT && msg->msg != WM_INPUT_DEVICE_CHANGE)
     {
         if (msg->msg == WM_MOUSEMOVE)
         {
@@ -1651,7 +1651,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
 static struct thread *get_foreground_thread( struct desktop *desktop, user_handle_t window )
 {
     /* if desktop has no foreground process, assume the receiving window is */
-    if (desktop->foreground_input) return get_window_thread( desktop->foreground_input->focus );
+    if (desktop && desktop->foreground_input) return get_window_thread( desktop->foreground_input->focus );
     if (window) return get_window_thread( window );
     return NULL;
 }
@@ -1692,12 +1692,23 @@ static void remove_hid_rawinput_device( unsigned int index )
     hid_rawinput_devices[index].usage = 0;
 }
 
+static struct rawinput_device_entry *find_hid_rawinput_device( struct process *process, const union rawinput *rawinput )
+{
+    unsigned int index;
+    if (rawinput->type != RIM_TYPEHID) return NULL;
+    if (!(index = rawinput->hid.device)) return NULL;
+    if (hid_rawinput_device_count < index) return NULL;
+    if (!hid_rawinput_devices[index].usage_page) return NULL;
+    return find_rawinput_device( process, hid_rawinput_devices[index].usage_page, hid_rawinput_devices[index].usage );
+}
+
 struct rawinput_message
 {
     struct thread           *foreground;
     struct desktop          *desktop;
     struct hw_msg_source     source;
     unsigned int             time;
+    unsigned int             message;
     struct hardware_msg_data data;
 };
 
@@ -1705,6 +1716,7 @@ struct rawinput_message
 static int queue_rawinput_message( struct process* process, void *arg )
 {
     const struct rawinput_message* raw_msg = arg;
+    const struct rawinput_device_entry *entry;
     const struct rawinput_device *device = NULL;
     struct desktop *target_desktop = NULL, *desktop = NULL;
     struct thread *target_thread = NULL, *foreground = NULL;
@@ -1715,8 +1727,12 @@ static int queue_rawinput_message( struct process* process, void *arg )
         device = process->rawinput_mouse;
     else if (raw_msg->data.rawinput.type == RIM_TYPEKEYBOARD)
         device = process->rawinput_kbd;
+    else if ((entry = find_hid_rawinput_device( process, &raw_msg->data.rawinput )))
+        device = &entry->device;
     if (!device) return 0;
 
+    if (raw_msg->message == WM_INPUT_DEVICE_CHANGE && !(device->flags & RIDEV_DEVNOTIFY)) return 0;
+
     if (raw_msg->desktop) desktop = (struct desktop *)grab_object( raw_msg->desktop );
     else if (!(desktop = get_desktop_obj( process, process->desktop, 0 ))) goto done;
 
@@ -1725,7 +1741,7 @@ static int queue_rawinput_message( struct process* process, void *arg )
 
     if (process != foreground->process)
     {
-        if (!(device->flags & RIDEV_INPUTSINK)) goto done;
+        if (raw_msg->message == WM_INPUT && !(device->flags & RIDEV_INPUTSINK)) goto done;
         if (!(target_thread = get_window_thread( device->target ))) goto done;
         if (!(target_desktop = get_thread_desktop( target_thread, 0 ))) goto done;
         if (target_desktop != desktop) goto done;
@@ -1736,11 +1752,17 @@ static int queue_rawinput_message( struct process* process, void *arg )
         goto done;
 
     msg->win    = device->target;
-    msg->msg    = WM_INPUT;
+    msg->msg    = raw_msg->message;
     msg->wparam = wparam;
     msg->lparam = 0;
     memcpy( msg->data, &raw_msg->data, sizeof(raw_msg->data) );
 
+    if (raw_msg->message == WM_INPUT_DEVICE_CHANGE && raw_msg->data.rawinput.type == RIM_TYPEHID)
+    {
+        msg->wparam = raw_msg->data.rawinput.hid.param;
+        msg->lparam = raw_msg->data.rawinput.hid.device;
+    }
+
     queue_hardware_message( desktop, msg, 1 );
 
 done:
@@ -1814,6 +1836,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         raw_msg.desktop    = desktop;
         raw_msg.source     = source;
         raw_msg.time       = time;
+        raw_msg.message    = WM_INPUT;
 
         msg_data = &raw_msg.data;
         msg_data->info                = input->mouse.info;
@@ -1948,6 +1971,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         raw_msg.desktop    = desktop;
         raw_msg.source     = source;
         raw_msg.time       = time;
+        raw_msg.message    = WM_INPUT;
 
         msg_data = &raw_msg.data;
         msg_data->info                 = input->kbd.info;
@@ -2003,18 +2027,35 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
                                            unsigned int origin, const hw_input_t *input )
 {
     struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
+    struct hardware_msg_data *msg_data;
+    struct rawinput_message raw_msg;
     struct message *msg;
 
     switch (input->hw.msg)
     {
     case WM_INPUT_DEVICE_CHANGE:
+        raw_msg.foreground = get_foreground_thread( desktop, win );
+        raw_msg.desktop    = desktop;
+        raw_msg.source     = source;
+        raw_msg.time       = get_tick_count();
+        raw_msg.message    = input->hw.msg;
+
+        msg_data = &raw_msg.data;
+        msg_data->info     = 0;
+        msg_data->flags    = 0;
+        msg_data->rawinput = input->hw.rawinput;
+
         if (input->hw.rawinput.type == RIM_TYPEHID &&
             input->hw.rawinput.hid.param == GIDC_ARRIVAL)
             insert_hid_rawinput_device( input->hw.rawinput.hid.device, get_req_data(), get_req_data_size() );
 
+        enum_processes( queue_rawinput_message, &raw_msg );
+
         if (input->hw.rawinput.type == RIM_TYPEHID &&
             input->hw.rawinput.hid.param == GIDC_REMOVAL)
             remove_hid_rawinput_device( input->hw.rawinput.hid.device );
+
+        if (raw_msg.foreground) release_object( raw_msg.foreground );
         return;
     }
 
@@ -2151,7 +2192,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
 
         data->hw_id = msg->unique_id;
         set_reply_data( msg->data, msg->data_size );
-        if (msg->msg == WM_INPUT && (flags & PM_REMOVE))
+        if ((msg->msg == WM_INPUT || msg->msg == WM_INPUT_DEVICE_CHANGE) && (flags & PM_REMOVE))
             release_hardware_message( current->queue, data->hw_id );
         return 1;
     }
-- 
2.30.2

